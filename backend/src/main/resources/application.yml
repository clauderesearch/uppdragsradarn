# Application
server:
  port: 8081
  servlet:
    session:
      timeout: 30m
      cookie:
        name: JSESSIONID
        path: /
        http-only: true
        secure: true

spring:
  application:
    name: uppdragsradarn-backend
  
  # Database
  datasource:
    url: jdbc:postgresql://localhost:5432/uppdragsradarn
    username: postgres
    password: postgres
    hikari:
      schema: uppdragsradarn

  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true
    open-in-view: true


  # Liquibase
  liquibase:
    enabled: true
    change-log: classpath:db/changelog/db.changelog-master.xml
    default-schema: uppdragsradarn

  # Elasticsearch
  elasticsearch:
    uris: http://localhost:9200

  # OAuth2 Cognito Configuration
  security:
    oauth2:
      client:
        registration:
          cognito:
            client-id: ${COGNITO_CLIENT_ID}
            client-secret: ${COGNITO_CLIENT_SECRET}
            scope: openid,email,phone
            redirect-uri: "{baseUrl}/login/oauth2/code/cognito"
            client-name: Cognito
            authorization-grant-type: authorization_code
          cognito-admin:
            client-id: ${COGNITO_CLIENT_ID}
            client-secret: ${COGNITO_CLIENT_SECRET}
            scope: openid,email,phone
            redirect-uri: "{baseUrl}/login/oauth2/code/cognito-admin"
            client-name: Cognito Admin
            authorization-grant-type: authorization_code
        provider:
          cognito:
            issuer-uri: https://cognito-idp.${COGNITO_REGION}.amazonaws.com/${COGNITO_USER_POOL_ID}
            user-name-attribute: email
          cognito-admin:
            issuer-uri: https://cognito-idp.${COGNITO_REGION}.amazonaws.com/${COGNITO_USER_POOL_ID}
            user-name-attribute: email
      resourceserver:
        jwt:
          issuer-uri: https://cognito-idp.${COGNITO_REGION}.amazonaws.com/${COGNITO_USER_POOL_ID}
  
  # Redis Configuration for distributed sessions
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    timeout: 2000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
  
  # Distributed Session Configuration  
  session:
    store-type: redis
    redis:
      namespace: uppdragsradarn:session
      flush-mode: on-save
      cleanup-cron: "0 * * * * *" # Run cleanup every minute
  
  # Docker Compose Configuration
  docker:
    compose:
      enabled: false
      file: ./compose.yaml
      lifecycle-management: start_and_stop
      start:
        command: up
        log-level: info
      stop:
        command: down

# Server configuration merged above

# Logging
logging:
  level:
    org:
      springframework: INFO
      springframework.security: DEBUG
      springframework.web: DEBUG
      hibernate:
        SQL: DEBUG
        type:
          descriptor:
            sql:
              BasicBinder: TRACE
    com:
      uppdragsradarn: DEBUG

# Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: when_authorized

# SpringDoc OpenAPI
springdoc:
  api-docs:
    path: /v3/api-docs
    enabled: true
    groups:
      enabled: true
  swagger-ui:
    path: /swagger-ui.html
    operationsSorter: method
    tagsSorter: alpha
    displayRequestDuration: true
    filter: true
    syntaxHighlight:
      activated: true
  pathsToMatch: /**
  group-configs:
    - group: api
      paths-to-match: /api/**
    - group: admin
      paths-to-match: /api/admin/**

# Custom application properties
app:
  frontend:
    url: ${FRONTEND_URL:http://localhost}
    admin-url: ${ADMIN_FRONTEND_URL:}
  allowed-origins: ${ALLOWED_ORIGINS:}

  # Rate Limiting Configuration
  rate-limiting:
    # Whether rate limiting is enabled
    enabled: ${RATE_LIMIT_ENABLED:true}
    # Maximum number of requests allowed within the time window
    capacity: ${RATE_LIMIT_CAPACITY:100}
    # Number of tokens to add during each refill
    refill-tokens: ${RATE_LIMIT_REFILL_TOKENS:10}
    # Time duration in minutes between refills
    refill-duration: ${RATE_LIMIT_REFILL_DURATION:1}

  # Crawler Configuration
  crawler:
    # Default scheduling (cron expression) - every 6 hours by default
    schedule: ${CRAWLER_SCHEDULE:0 0 */6 * * *}
    # HTTP request timeout in seconds
    timeout: ${CRAWLER_TIMEOUT:30}
    # User agent to use for crawlers
    user-agent: ${CRAWLER_USER_AGENT:Mozilla/5.0 (compatible; UppdragsRadarn/1.0; +https://uppdragsradarn.se/bot)}
    # Max assignments to process per source
    max-assignments: ${CRAWLER_MAX_ASSIGNMENTS:200}
    # Automatically index new assignments in Elasticsearch
    auto-index: ${CRAWLER_AUTO_INDEX:true}
    # Run crawler on application startup if no assignments exist
    init-on-startup: ${CRAWLER_INIT_ON_STARTUP:true}
    # Source-specific configuration
    asocietygroup:
      # ASociety Group now always uses Playwright (requires Playwright installation)
      use-playwright: true

  # OpenAI LLM Configuration for job detail extraction
  openai:
    # OpenAI API key (set via environment variable OPENAI_API_KEY)
    api-key: ${OPENAI_API_KEY:}
    # Default model to use for extraction
    model: ${OPENAI_MODEL:gpt-4o-mini}
    # Request timeout in seconds
    timeout-seconds: ${OPENAI_TIMEOUT_SECONDS:30}